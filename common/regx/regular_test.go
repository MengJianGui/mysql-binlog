package regx

import (
	"fmt"
	"testing"
)

func TestRegMatch(t *testing.T) {
	// rename table
	sql := "RENAME TABLE `b2b_trade100`.`b2b_order_main` TO `b2b_trade100`.`_b2b_order_main_old`, `b2b_trade100`.`_b2b_order_main_new` TO `b2b_trade100`.`b2b_order_main`"
	if tbs, ok := RegMatch([]byte("test"), []byte(sql)); ok {
		for _, tb := range tbs {
			fmt.Println(string(tb))
		}
	}

	sql = "RENAME TABLE `tob`.`tb1` TO `tob`.`tb2`, `tob`.`tb2` TO `tob`.`tb1`"
	if tbs, ok := RegMatch([]byte("test"), []byte(sql)); ok {
		for _, tb := range tbs {
			fmt.Println(string(tb))
		}
	}
}

func TestStripQuote(t *testing.T) {
	tb := "`b2b_trade100`.`b2b_order_main`"
	fmt.Println(string(StripQuoteAndAppendDb([]byte(tb), []byte("test"))))
}

func TestBytemap(t *testing.T) {
	a := make(map[string]string)
	a["abc"] = "ab"
	for k, v := range a {
		print("key = ", k, ",value = ", v)
	}
}

func TestRegMatch2(t *testing.T) {
	cases := []string{
		"CREATE TABLE `position` (`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',",
		"CREATE TABLE `position`(`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',",
		"CREATE				 TABLE `mydb.mytable` (`id` int(10)) ENGINE=InnoDB",
		"CREATE TABLE `mytable` (`id` int(10)) ENGINE=InnoDB",
		"CREATE TABLE IF NOT EXISTS `mytable` (`id` int(10)) ENGINE=InnoDB",
		"CREATE TABLE IF NOT EXISTS mytable (`id` int(10)) ENGINE=InnoDB",
	}
	db := []byte("mydb")

	for _, ddl := range cases {
		if tbs, matched := RegMatch(db, []byte(ddl)); matched { // 匹配表名成功
			for _, tb := range tbs {
				fmt.Println(string(tb))
			}
		} else {
			// not match tables ddl sql then just write to common packet
			fmt.Println("not matched")
		}
	}
}

func TestRegMatch4(t *testing.T) {
	cases := []string{
		"drop table test1",
		"DROP			 TABLE test1",
		"DROP TABLE test1",
		"DROP table IF EXISTS test.test1",
		"drop table `test1`",
		"DROP TABLE `test1`",
		"DROP table IF EXISTS `test`.`test1`",
		"DROP TABLE `test1` /* generated by server */",
		"DROP table if exists test1",
		"DROP table if exists `test1`",
		"DROP table if exists test.test1",
		"DROP table if exists `test`.test1",
		"DROP table if exists `test`.`test1`",
		"DROP table if exists test.`test1`",
		"DROP table if exists test.`test1`",
	}
	for _, ddl := range cases {
		if tbs, matched := RegMatch([]byte("test"), []byte(ddl)); matched { // 匹配表名成功
			for _, tb := range tbs {
				fmt.Println(string(tb))
			}
		} else {
			// not match tables ddl sql then just write to common packet
			fmt.Println("not matched")
		}
	}
}

func TestRegMatch5(t *testing.T) {
	cases := []string{
		"rename 			table `mydb`.`mytable` to `mydb`.`mytable1`",
		"rename table `mytable` to `mytable1`",
		"rename table mydb.mytable to mydb.mytable1",
		"rename table mytable to mytable1",

		"rename table `mydb`.`mytable` to `mydb`.`mytable2`, `mydb`.`mytable3` to `mydb`.`mytable1`",
		"rename table `mytable` to `mytable2`, `mytable3` to `mytable1`",
		"rename table mydb.mytable to mydb.mytable2, mydb.mytable3 to mydb.mytable1",
		"rename table mytable to mytable2, mytable3 to mytable1",
	}
	db := []byte("mydb")
	for _, ddl := range cases {
		if tbs, matched := RegMatch(db, []byte(ddl)); matched { // 匹配表名成功
			for _, tb := range tbs {
				fmt.Println(string(tb))
			}
		} else {
			// not match tables ddl sql then just write to common packet
			fmt.Println("not matched")
		}
	}
}

func TestRegMatch6(t *testing.T) {
	cases := []string{
		"ALTER TABLE 		`mydb.mytable` ADD `field2` DATE  NULL  AFTER `field1`;",
		"ALTER TABLE `mydb`.`mytable` ADD `field2` DATE  NULL  AFTER `field1`;",
		"ALTER TABLE `myTable` ADD `field2` DATE  NULL  AFTER `field1`;",
		"ALTER TABLE mydb.mytable ADD `field2` DATE  NULL  AFTER `field1`;",
		"ALTER TABLE mytable ADD `field2` DATE  NULL  AFTER `field1`;",
		"ALTER TABLE mydb.mytable ADD field2 DATE  NULL  AFTER `field1`;",
	}

	for _, ddl := range cases {
		if tbs, matched := RegMatch([]byte("mydb"), []byte(ddl)); matched { // 匹配表名成功
			for _, tb := range tbs {
				fmt.Println(string(tb))
			}
		} else {
			// not match tables ddl sql then just write to common packet
			fmt.Println("not matched")
		}
	}
}

func TestRegMatch3(t *testing.T) {
	cases := []string{
		"CREATE INDEX k_1 ON sbtest1(k)",
		"CREATE INDEX k_1 ON sysbench.sbtest1(k)",
		"CREATE INDEX k_1 ON `sysbench`.`sbtest1`(k)",
		}
	for _, ddl := range cases {
		if tbs, matched := RegMatch([]byte("mydb"), []byte(ddl)); matched { // 匹配表名成功
			for _, tb := range tbs {
				fmt.Println(string(tb))
			}
		} else {
			// not match tables ddl sql then just write to common packet
			fmt.Println("not matched")
		}
	}
}